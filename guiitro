# Show summary log as message box
        try:
            with open(packet_filter.SUMMARY_LOG_FILE, "r") as f:
                summary = f.read().strip()
            messagebox.showinfo("Capture Summary", f"Capture stopped.\n\nSummary:\n{summary}")
        except Exception as e:
            messagebox.showerror("Error", f"Error reading summary log: {str(e)}")
        
        self.status_text.config(text="Status: Stopped")
        self.log_action("Stopped packet capture")
        
        # Clear all logs after stopping capture
        self.clear_logs()

    def clear_logs(self):
        # Clear the log text areas in the GUI
        self.allowed_log.delete(1.0, tk.END)
        self.blocked_log.delete(1.0, tk.END)
        self.stats_display.delete(1.0, tk.END)
        self.alert_log.delete(1.0, tk.END)
        
        # Reset packet count
        self.packet_count = 0
        self.update_packet_counter()
        
        # File paths for the log files
        log_files = [
            "logs/summary.log",
            "logs/blocked.log",
            "logs/allowed.log",
            "logs/maliscious.log"
        ]
        
        # Clear the contents of the log files
        for log_file in log_files:
            try:
                with open(log_file, "w") as file:
                    file.truncate(0)  # Clears the file content
            except Exception as e:
                self.log_action(f"Error clearing log file {log_file}: {str(e)}")
        
        # Also clear the summary log file
        try:
            with open(packet_filter.SUMMARY_LOG_FILE, "w") as file:
                packet_filter.packet_summary={  # Reset the packet summary
                    "total": 0,
                    "allowed": 0,
                    "blocked": 0,
                    "malicious": 0
                }
                file.truncate(0)  # Clears the file content
        except Exception as e:
            self.log_action(f"Error clearing summary log file: {str(e)}")
    
        # Log the clear action
        self.log_action("Cleared all logs, including summary")

    def update_logs(self):
        try:
            # Update allowed log
            with open(packet_filter.ALLOWED_LOG_FILE, "r") as f:
                current_allowed = self.allowed_log.get(1.0, tk.END).strip()
                new_allowed = f.read().strip()
                if new_allowed != current_allowed:
                    self.allowed_log.delete(1.0, tk.END)
                    self.allowed_log.insert(tk.END, new_allowed)
                    self.allowed_log.see(tk.END)
            
            # Update blocked log
            with open(packet_filter.ALERT_LOG_FILE, "r") as f:
                current_blocked = self.blocked_log.get(1.0, tk.END).strip()
                new_blocked = f.read().strip()
                if new_blocked != current_blocked:
                    self.blocked_log.delete(1.0, tk.END)
                    self.blocked_log.insert(tk.END, new_blocked)
                    self.blocked_log.see(tk.END)

            with open(packet_filter.Maliscious_LOG_FILE, "r") as f:
                current_alerts = self.alert_log.get(1.0, tk.END).strip()
                new_alerts = f.read().strip()
                if new_alerts != current_alerts:
                    self.alert_log.delete(1.0, tk.END)
                    self.alert_log.insert(tk.END, new_alerts)
                    self.alert_log.see(tk.END)
                    # Check for DoS attack message
                    if "Detected DoS Attack" in new_alerts:
                        self.show_alert("DoS Attack Detected!", "Warning: A Denial of Service (DoS) attack has been detected!")
            
            # Update statistics
            with open(packet_filter.SUMMARY_LOG_FILE, "r") as f:
                current_stats = self.stats_display.get(1.0, tk.END).strip()
                new_stats = f.read().strip()
                if new_stats != current_stats:
                    self.stats_display.delete(1.0, tk.END)
                    self.stats_display.insert(tk.END, new_stats)
                    self.packet_count = packet_filter.packet_summary["total"]
                    
        except Exception as e:
            self.log_action(f"Error updating logs: {str(e)}")
        
        # Schedule next update
        self.root.after(1000, self.update_logs)

    def show_alert(self, title, message):
        # Show a warning message with an icon and sound
        messagebox.showwarning(title, message)
        
        # Play a warning sound (Windows-specific)
        winsound.Beep(1000, 500)  # 1000 Hz for 500 ms

    def update_status(self):
        current_time = datetime.now().strftime("%H:%M:%S")
        self.status_text.config(text=f"Status: {'Capturing' if self.is_capturing else 'Ready'} | Time: {current_time}")
        self.root.after(1000, self.update_status)

    def update_packet_counter(self):
        self.packet_counter.config(text=f"Packets: {self.packet_count}")

    def update_rule_displays(self):
        # Schedule the next refresh
        self.root.after(1000, self.update_rule_displays)
        # Update IP display
        self.blacklist_display.delete(1.0, tk.END)
        ips = "\n".join(packet_filter.BLACKLISTED_IPS) if packet_filter.BLACKLISTED_IPS else "No blacklisted IPs"
        self.blacklist_display.insert(tk.END, ips)
        
        # Update Port display
        self.ports_display.delete(1.0, tk.END)
        ports = "\n".join(map(str, packet_filter.BLOCKED_PORTS)) if packet_filter.BLOCKED_PORTS else "No blocked ports"
        self.ports_display.insert(tk.END, ports)

    def log_action(self, message):
        # Add to logs with timestamp
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        print(f"{timestamp} - {message}")

    def add_ip(self):
        ip = self.ip_entry.get().strip()
        if ip and ip not in packet_filter.BLACKLISTED_IPS:
            packet_filter.add_blacklisted_ip(ip)
            self.update_rule_displays()
            self.log_action(f"Added IP: {ip}")
        else:
            messagebox.showerror("Invalid IP", "Invalid or duplicate IP address.")

    def remove_ip(self):
        ip = self.ip_entry.get().strip()
        if ip and ip in packet_filter.BLACKLISTED_IPS:
            packet_filter.remove_blacklisted_ip(ip)
            self.update_rule_displays()
            self.log_action(f"Removed IP: {ip}")
        else:
            messagebox.showerror("Invalid IP", "IP address not found in blacklist.")

    def add_port(self):
        port = self.port_entry.get().strip()
        if port.isdigit() and 1 <= int(port) <= 65535 and int(port) not in packet_filter.BLOCKED_PORTS:
            packet_filter.add_blocked_port(int(port))
            self.update_rule_displays()
            self.log_action(f"Added port: {port}")
        else:
            messagebox.showerror("Invalid Port", "Invalid or duplicate port.")

    def remove_port(self):
        port = self.port_entry.get().strip()
        if port.isdigit() and int(port) in packet_filter.BLOCKED_PORTS:
            packet_filter.remove_blocked_port(int(port))
            self.update_rule_displays()
            self.log_action(f"Removed port: {port}")
        else:
            messagebox.showerror("Invalid Port", "Port not found in blocked ports.")
    def apply_max_packet_size(self):
        size = self.size_entry.get().strip()
        if size.isdigit() and int(size) > 0:
            packet_filter.MAX_PACKET_SIZE = int(size)
            self.log_action(f"Set MAX_PACKET_SIZE to {size} bytes")
        else:
            messagebox.showerror("Invalid Size", "Invalid packet size.")

    def apply_dos_threshold(self):
        threshold = self.dos_threshold_entry.get().strip()
        if threshold.isdigit() and int(threshold) > 0:
            packet_filter.DOS_THRESHOLD = int(threshold)
            self.log_action(f"Set DOS_THRESHOLD to {threshold} packets/IP")
        else:
            messagebox.showerror("Invalid Threshold", "Invalid DoS threshold.")

    def apply_dos_interval(self):
        interval = self.dos_interval_entry.get().strip()
        if interval.isdigit() and int(interval) > 0:
            packet_filter.DOS_TIME_INTERVAL = int(interval)
            self.log_action(f"Set DOS_TIME_INTERVAL to {interval} seconds")
        else:
            messagebox.showerror("Invalid Interval", "Invalid DoS time interval.")


# Main execution
if _name_ == "_main_":
    root = tk.Tk()
    gui = FirewallGUI(root)
    root.mainloop()
